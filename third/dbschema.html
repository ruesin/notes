<!DOCTYPE HTML>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>详解Ecstore中的数据表结构定义文件dbschema-信口开河</title>
    <meta name="keywords" content="Ruesin,信口开河">
    <meta name="description" content="至于你信不信，反正我是信了。">
    <link rel="stylesheet" href="/css/style.css">
</head>
  <body>
    
<header class="header">
    <nav class="navbar">
        <ul>
            
            <li><a class="header-nav-link" href="/">首页</a></li>
            
            <li><a class="header-nav-link" href="/categories">分类</a></li>
            
            <li><a class="header-nav-link" href="/archives">归档</a></li>
            
            <li><a class="header-nav-link" href="/tags">标签</a></li>
            
            <li><a class="header-nav-link" href="https://github.com/ruesin/notes">Github</a></li>
            
            <li><a class="header-nav-link" href="https://ruesin.github.io/php-tree">PHP技能树</a></li>
            
            <li><a class="header-nav-link" href="https://www.xinkoukaihe.com">老博客</a></li>
            
        </ul>
    </nav>
</header>
    <main class="main">
      <!-- 内容页 -->
<section class="section">
    <div class="post-container">
        <div class="post-header">
                <h1>详解Ecstore中的数据表结构定义文件dbschema</h1>
                <!-- <div class="post-meta">2014-04-10</div> -->
        </div>
        <article class="post-content">
            <p>任何系统的操作无非都是对数据库的各种操作的结合,而对于ecstore的数据库操作可能与其他常见项目有些不太一样.<br>可能有新入手的朋友会尝试在数据库中直接创建表,可是发现创建之后不能使用,那是因为ecstore的缓存机制的原因.<br>ecstore的数据库表不是常规那种直接在数据库中操作增删表的,而是通过定义dbschema目录下的数据表文件进行定义.<br>官方目录结构对dbschema目录的解释是:</p>
<p><code>app/{$app_name}/dbschema    {$app_name}的数据库表定义文件</code>通过文档可以理解,在ecos安装时,会扫描相关app中的dbschema中的文件,用这个文件生成相应的表结构并创建,同时也用来定义desktop app的列表项,即finder列表及操作项.</p>
<p>通常情况下数据库的一个表会对应一个dbschema定义文件(数据库表定义文件)和一个model.数据库表名采用下划线命名法, 并且只允许小写字母.<br><strong>dbschema约定:</strong><br>表名: {$db_prefix}{$app_name}_{$filename}<br>数据库表名前缀: {$db_prefix} 系统默认为sdb_, 定义在config/config.php里, DB_PREFIX<br>文件名: $filename.php<br>存放目录名: app/{$app_name}/dbschema<br>完整文件名: app/{$app_name}/dbschema/{$filename}.php<br>对应的model类名: {$app_name}_mdl_{$filename}<br>所属app: {$app_name}</p>
<p>dbschema文件内容返回的是一个数组形式,每个键值都有不同的定义,下面给出一个简单的例子加以说明.</p>
<pre><code>$db[&#39;members&#39;]=array (
    &#39;columns&#39; =&gt; array(
        &#39;ruesin_id&#39; =&gt;  //键值即是字段名称
        array (
            &#39;type&#39; =&gt; &#39;int(8)&#39;,                       // 字段类型
            &#39;pkey&#39; =&gt; true,                           // 是否是主键 默认为false
            &#39;required&#39; =&gt; true,                       // 不能为空 默认为false
            &#39;extra&#39; =&gt; &#39;auto_increment&#39;,              // 扩展值//自增//如果要用一般只使用这个即可
            &#39;comment&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;用户名&#39;),//注释
            &#39;sdfpath&#39; =&gt; &#39;pam_account/account_id&#39;,    //保存数据时的数组格式
            &#39;label&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;用户名&#39;),  //显示的名称
            &#39;width&#39; =&gt; 110,                           //本列的初始宽度
            &#39;searchtype&#39; =&gt; &#39;has&#39;,                    //搜索的类型//详细可参考数据查询过滤器_filter
            &#39;filtertype&#39; =&gt; &#39;normal&#39;,                 //高级筛选的过滤类型//设置为normal按type的来生成过滤
            &#39;filterdefault&#39; =&gt; &#39;true&#39;,                //默认在高级筛选中显示
            &#39;order&#39; =&gt; 20,                            //在列表中的权重//越小越靠前
            &#39;in_list&#39; =&gt; true,                        //是否显示在列表项中
            &#39;default_in_list&#39; =&gt; true,                //默认显示在列表项中
            &#39;is_title&#39;=&gt;true,
        ),
        &#39;member_lv_id&#39; =&gt;
        array(
            &#39;type&#39; =&gt; &#39;table:member_lv@b2c&#39;,           //关联b2c app下member_lv表中的主键类型
            &#39;default&#39; =&gt; 0,                            // 默认值
            &#39;required&#39; =&gt; true,
            &#39;editable&#39; =&gt; false,
        ),
        &#39;status&#39; =&gt;
        array(
            &#39;default&#39; =&gt; &#39;programmer&#39;,
            &#39;type&#39; =&gt; array (     // 生成枚举类型
            &#39;programmer&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;程序员&#39;),
            &#39;literature&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;文艺青年&#39;),
            ),
            &#39;label&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;身份&#39;),
            &#39;width&#39; =&gt; 100,
            &#39;in_list&#39; =&gt; true,
            &#39;default_in_list&#39; =&gt; true,
        )
    ),
    &#39;version&#39; =&gt; &#39;$Rev: 44008 $&#39; ,                       //版本号
    &#39;engine&#39; =&gt; &#39;innodb&#39; ,                               //mysql引擎
    &#39;comment&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;Ruesin的数据表&#39;),   //表描述
);</code></pre><h4 id="一、字段类型"><a href="#一、字段类型" class="headerlink" title="一、字段类型"></a>一、字段类型</h4><p>系统中定义的字段类型有很多,详细可查询官方文档,这里只列出了一些比较特别的.并稍作介绍.<br><strong>1.关联主键表</strong></p>
<pre><code>&#39;type&#39; =&gt; &#39;table:member_lv@b2c&#39;,
//关联b2c应用下member_lv表中的主键类型
//如果在同一app下,可省略@appname</code></pre><p><strong>2.枚举类型</strong></p>
<pre><code>&#39;type&#39; =&gt; array (
    &#39;programmer&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;程序员&#39;),
    &#39;literature&#39; =&gt; app::get(&#39;b2c&#39;)-&gt;_(&#39;文艺青年&#39;),
),
// 生成枚举类型 enum(&#39;programmer&#39;,&#39;literature&#39;)
// 高级搜索将产生一个select选项可以进行选择
// 在后台finder列表中,会根据查询出来的值显示出枚举出的数据</code></pre><p><strong>3.email类型</strong><br>//存在数据库中的类型是varchar(255),虽然可以直接写成mysql类型,但在这里写了email类型后,使用dbeav的save时会验证是否是email类型的数据 如果不是将抛出异常.<br>(跟money类型异曲同工,其实有很多类型由于在程序中我们都有验证,所以可以直接写成mysql类型的)</p>
<h4 id="二、后台finder列表"><a href="#二、后台finder列表" class="headerlink" title="二、后台finder列表"></a>二、后台finder列表</h4><p><strong>1.searchtype</strong><br>列表页中简单搜索的处理方式,如果dbschema中存在searchtype则会在desktop列表上显示相关的简单搜索,而searchtype的类型使用的是dbeav中的过滤器_filter类型</p>
<pre><code>&#39;than&#39;=&gt;&#39; &gt; &#39;.$var,
&#39;lthan&#39;=&gt;&#39; &lt; &#39;.$var,
&#39;nequal&#39;=&gt;&#39; = \&#39;&#39;.$var.&#39;\&#39;&#39;,
&#39;noequal&#39;=&gt;&#39; &lt;&gt; \&#39;&#39;.$var.&#39;\&#39;&#39;,
&#39;tequal&#39;=&gt;&#39; = \&#39;&#39;.$var.&#39;\&#39;&#39;,
&#39;sthan&#39;=&gt;&#39; &lt;= &#39;.$var,
&#39;bthan&#39;=&gt;&#39; &gt;= &#39;.$var,
&#39;has&#39;=&gt;&#39; like \&#39;%&#39;.$var.&#39;%\&#39;&#39;,
&#39;head&#39;=&gt;&#39; like \&#39;&#39;.$var.&#39;%\&#39;&#39;,
&#39;foot&#39;=&gt;&#39; like \&#39;%&#39;.$var.&#39;\&#39;&#39;,
&#39;nohas&#39;=&gt;&#39; not like \&#39;%&#39;.$var.&#39;%\&#39;&#39;,
&#39;between&#39;=&gt;&#39; {field}&gt;=&#39;.$var[0].&#39; and &#39;.&#39; {field}&lt;&#39;.$var[1],
&#39;in&#39; =&gt;&quot; in (&#39;&quot;.implode(&quot;&#39;,&#39;&quot;,(array)$var).&quot;&#39;) &quot;,
</code></pre><h4 id="三、sdfpath"><a href="#三、sdfpath" class="headerlink" title="三、sdfpath"></a>三、sdfpath</h4><p>刚开始看到sdfpath时感觉有点***,也不知道是哪位高人前辈命名的<del>平时自己做的app也很少用到,所以也没做过多注意.<br>后来二开order时,又看到这个,感觉好二</del> 于是有看了下dbschema里后理解了,说下自己的见解,也给大家起点抛砖引玉的作用.</p>
<pre><code>&#39;name&#39; =&gt;
array(
    &#39;type&#39; =&gt; &#39;varchar(20)&#39;,
),
&#39;email&#39; =&gt;
array(
    &#39;type&#39; =&gt; &#39;email&#39;,
    &#39;sdfpath&#39; =&gt; &#39;connect/email&#39;,
),</code></pre><p>保存的时候,POST的数组是:</p>
<pre><code>$_POST=array(
    &#39;name&#39;=&gt;&#39;Ruesin&#39;,
    &#39;connect&#39;=&gt;array(
        &#39;email&#39;=&gt;&#39;ruesin@163.com&#39;,
    )
);</code></pre><p>至此,数据表定义文件dbschema已经大体给介绍完了,虽然有很多详细细节没有讲解,但是结合官方文档查看即可,而本文的介绍的很多是官方文档没有明确介绍的部分,大家可以拿此文和官方文档一起学习.</p>
<p>创建好dbschema文件后,记得cmd update一下哦,不然是无法更新出数据表的~~</p>

        </article>
    </div>
</section>

    </main>
    <footer class="footer"> Copyright 2013 - 2019 Ruesin. All Rights Reserved </footer>
  </body>
</html>