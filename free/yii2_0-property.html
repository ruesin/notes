<!DOCTYPE HTML>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>Yii 2.0 对象加载时，对属性的处理过程-信口开河</title>
    <meta name="keywords" content="Ruesin,信口开河">
    <meta name="description" content="至于你信不信，反正我是信了。">
    <link rel="stylesheet" href="/css/style.css">
</head>
  <body>
    
<header class="header">
    <nav class="navbar">
        <ul>
            
            <li><a class="header-nav-link" href="/">首页</a></li>
            
            <li><a class="header-nav-link" href="/categories">分类</a></li>
            
            <li><a class="header-nav-link" href="/archives">归档</a></li>
            
            <li><a class="header-nav-link" href="/tags">标签</a></li>
            
            <li><a class="header-nav-link" href="https://github.com/ruesin/notes">Github</a></li>
            
            <li><a class="header-nav-link" href="https://ruesin.github.io/php-tree">PHP技能树</a></li>
            
            <li><a class="header-nav-link" href="https://www.xinkoukaihe.com">老博客</a></li>
            
        </ul>
    </nav>
</header>
    <main class="main">
      <!-- 内容页 -->
<section class="section">
    <div class="post-container">
        <div class="post-header">
                <h1>Yii 2.0 对象加载时，对属性的处理过程</h1>
                <!-- <div class="post-meta">2015-04-16</div> -->
        </div>
        <article class="post-content">
            <p>由于工作中暂时没有用到yii，而自己平时又太多的杂事，似乎都没怎么深入过，着实惭愧。<br>重新看深入理解yii2.0，似乎更加清晰，本文就是按照自己的理解写一下yii对象加载时，对属性的处理过程。</p>
<p>打开当前应用下的入口文件，可以看到加载了很多配置文件，其实这些配置文件就是一个各种配置项的数组，Yii中就是通过这些数组对对象进行配置的，这一方式贯穿整个Yii。</p>
<pre><code>// comment out the following two lines when deployed to production
defined(&#39;YII_DEBUG&#39;) or define(&#39;YII_DEBUG&#39;, true);
defined(&#39;YII_ENV&#39;) or define(&#39;YII_ENV&#39;, &#39;dev&#39;);

require(__DIR__ . &#39;/../vendor/autoload.php&#39;);
require(__DIR__ . &#39;/../vendor/yiisoft/yii2/Yii.php&#39;);

$config = require(__DIR__ . &#39;/../config/web.php&#39;);

(new yii\web\Application($config))-&gt;run();</code></pre><p>那么这个所谓的配置数组是在哪里用到的呢，逐级追可以看到在 yii\base\Object 的构造函数中:</p>
<pre><code>public function __construct($config = [])
{
    if (!empty($config)) {
        Yii::configure($this, $config);
    }
    $this-&gt;init();
}</code></pre><p>而 Yii::configure() 是何许人也？其实此方法只是执行了一个数组遍历，将配置数组的键作为属性名，将对应数组元素的值为对象的属性赋值。</p>
<pre><code>public static function configure($object, $properties)
{
    foreach ($properties as $name =&gt; $value) {
        $object-&gt;$name = $value;
    }

    return $object;
}</code></pre><p>这样你配置数据就可以通过访问 Yii 的属性进行访问了。</p>
<p>但是，到这里还没有完，Yii很多默认的组件，比如 Yii::$app-&gt;request ，是配置文件中 components 的嵌套配置数组里的，但是也是直接访问的，是哪里做的处理呢？</p>
<p>在Yii的规则里，如果一个属性是对象，那么他就要通过数组来进行配置。Yii应用 yii\web\Application 就是依靠定义专门的setter函数，实现自动处理配置项的。比如，我们上面说的配置项 components 的内容是这样的:</p>
<pre><code>&#39;components&#39; =&gt; [
    &#39;request&#39; =&gt; [
        // !!! insert a secret key in the following (if it is empty) -
        // this is required by cookie validation
        &#39;cookieValidationKey&#39; =&gt; &#39;Ruesin&#39;,
    ],
    &#39;user&#39; =&gt; [
        &#39;identityClass&#39; =&gt; &#39;common\models\User&#39;,
        &#39;enableAutoLogin&#39; =&gt; true,
    ],
    &#39;log&#39; =&gt; [
        &#39;traceLevel&#39; =&gt; YII_DEBUG ? 3 : 0,
        &#39;targets&#39; =&gt; [
            [
                &#39;class&#39; =&gt; &#39;yii\log\FileTarget&#39;,
                &#39;levels&#39; =&gt; [&#39;error&#39;, &#39;warning&#39;],
            ],
        ],
    ],
    &#39;errorHandler&#39; =&gt; [
        &#39;errorAction&#39; =&gt; &#39;site/error&#39;,
    ],
],</code></pre><p>Yii 在服务定位器 yii\di\ServiceLocator 中定义了一个名为 setComponents 的setter函数。</p>
<pre><code>public function setComponents($components)
{
    foreach ($components as $id =&gt; $component) {
        $this-&gt;set($id, $component);
    }
}</code></pre><pre><code>public function set($id, $definition)
{
    if ($definition === null) {
        unset($this-&gt;_components[$id], $this-&gt;_definitions[$id]);
        return;
    }

    unset($this-&gt;_components[$id]);

    if (is_object($definition) || is_callable($definition, true)) {
        // an object, a class name, or a PHP callable
        $this-&gt;_definitions[$id] = $definition;
    } elseif (is_array($definition)) {
        // a configuration array
        if (isset($definition[&#39;class&#39;])) {
            $this-&gt;_definitions[$id] = $definition;
        } else {
            throw new InvalidConfigException(&quot;The configuration for the \&quot;$id\&quot; component must contain a \&quot;class\&quot; element.&quot;);
        }
    } else {
        throw new InvalidConfigException(&quot;Unexpected configuration type for the \&quot;$id\&quot; component: &quot; . gettype($definition));
    }
}</code></pre><p>这个方法服务定位器用来注册服务的方法。通过这个方法判断配置文件中的 components 配置项是对象还是数组，如果是数组就实例化成对象。并在 setComponents 方法中将对象赋值给 app 的属性。</p>
<p>所有 yii\base\Object 的构建流程是：</p>
<p> 1.引入由外部代码或者通过配置文件规范的配置数组项。<br> 2.yii\base\Object 构造函数，设置属性的默认值，加载配置数组。<br> 3.通过构造函数调用 Yii::configure($this, $config) 设置对象属性的默认值，重写上一步的属性值。如果对象属性还是一个对象或数组，定义并调用 setKey 的setter方法，将数组实例化成对象再复制给app对象的属性。比如我们常用的组件对象就是使用 setComponents 将各个组件实例化成对象并赋值给app对象的属性的。<br> 4.如上步骤完成后，调用初始化方法 init() ，通过在 init() 写入代码，可以对配置阶段设置的值进行检查，并规范类的property。</p>
<p>此时，该对象的状态是确定且可靠的，不存在不确定的property。 所有的属性要么是默认值，要么是传入的配置值，如果传入的配置有误或者冲突，那么也经过了检查和规范。 也就是说，你就放心用吧。</p>
<p>如果你的对象继承自 yii\base\Object 。那么你要做到一下几点：<br> 为对象属性提供setter方法，以正确处理配置过程。<br> 如果需要重载构造函数， $config 要作为该构造函数的最后一个参数，并要传递该参数给父构造函数。<br> 重载的构造函数的最后，一定记得调用父构造函数。<br> 如果重载了初始化方法 init()，注意一定要在重载方法的开头调用父类的 init() 。</p>

        </article>
    </div>
</section>

    </main>
    <footer class="footer"> Copyright 2013 - 2019 Ruesin. All Rights Reserved </footer>
  </body>
</html>